<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>AspectJ和Spring的AOP | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="最近在看大佬讲的AOP感觉很深入，有一些东西自己已经知道了，有一些却是需要精进的，简单罗列一些自己的收入。原来AspectJ和Spring aop是不同的，一直以为这俩是同一个东东，今天才了解到根本。文中很多例子都是从大佬文章中拷贝而来，自己对重点部分做了理解。 一、AspectJAspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法，它有一个专门的编辑器用来生成">
<meta property="og:type" content="article">
<meta property="og:title" content="AspectJ和Spring的AOP">
<meta property="og:url" content="http://yoursite.com/2020/01/02/AspectJ%E5%92%8CSpring%E7%9A%84AOP/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="最近在看大佬讲的AOP感觉很深入，有一些东西自己已经知道了，有一些却是需要精进的，简单罗列一些自己的收入。原来AspectJ和Spring aop是不同的，一直以为这俩是同一个东东，今天才了解到根本。文中很多例子都是从大佬文章中拷贝而来，自己对重点部分做了理解。 一、AspectJAspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法，它有一个专门的编辑器用来生成">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-01-02T12:47:55.000Z">
<meta property="article:modified_time" content="2020-01-02T13:14:52.618Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-AspectJ和Spring的AOP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/02/AspectJ%E5%92%8CSpring%E7%9A%84AOP/" class="article-date">
  <time datetime="2020-01-02T12:47:55.000Z" itemprop="datePublished">2020-01-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      AspectJ和Spring的AOP
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在看<a href="https://blog.csdn.net/javazejian/article/details/56267036" target="_blank" rel="noopener">大佬讲的AOP</a>感觉很深入，有一些东西自己已经知道了，有一些却是需要精进的，简单罗列一些自己的收入。原来AspectJ和Spring aop是不同的，一直以为这俩是同一个东东，今天才了解到根本。文中很多例子都是从大佬文章中拷贝而来，自己对重点部分做了理解。</p>
<h3 id="一、AspectJ"><a href="#一、AspectJ" class="headerlink" title="一、AspectJ"></a>一、AspectJ</h3><p>AspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法，它有一个专门的编辑器用来生成遵守Java字节编码规范的Class文件。是它定义了Aop的概念及基本功能，SpringAop仅仅是它的一个实现方案，算是一个载体而已。从大佬那搞来的例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zejian on 2017/2/15.</span></span><br><span class="line"><span class="comment"> * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWord</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        HelloWord helloWord =<span class="keyword">new</span> HelloWord();</span><br><span class="line">        helloWord.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「zejian_」的原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/javazejian/article/details/56267036</span></span><br></pre></td></tr></table></figure>

<p>编写的AspectJ类，注意关键字为Aspect，含义与class相同，即定义一个AspectJ的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zejian on 2017/2/15.</span></span><br><span class="line"><span class="comment"> * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWord</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        HelloWord helloWord =<span class="keyword">new</span> HelloWord();</span><br><span class="line">        helloWord.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「zejian_」的原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/javazejian/article/details/56267036</span></span><br></pre></td></tr></table></figure>

<p>运行helloworld的main函数，切面运行正常。</p>
<p>把AspectJ应用到java代码的过程称为织入，对于织入，可以理解为切面应用到目标函数的过程，对于这个过程一般分为静态织入和动态织入，动态织入就比如Spring的Aop，而AspectJ用的就是静态织入，它拥有自己的编译器，在编译期织入，使用AspectJ的acj编译器（类似javac）把aspect类编译成class字节码后，在java目标类编译时织入，即先编译aspect类再编译目标类。aspect如何安装到idea中，请见上面大神的博客，里面描写的很详细，不再赘述。</p>
<h3 id="二、Spring-Aop开发"><a href="#二、Spring-Aop开发" class="headerlink" title="二、Spring Aop开发"></a>二、Spring Aop开发</h3><p>怎么开发大家都知道，今天就来科普一下细节</p>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><ul>
<li>.. :匹配方法定义中的任意数量的参数，此外还匹配类定义中的任意数量包</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任意返回值，任意名称，任意参数的公共方法</span></span><br><span class="line">execution(<span class="keyword">public</span> * *(..))</span><br><span class="line"><span class="comment">//匹配com.zejian.dao包及其子包中所有类中的所有方法</span></span><br><span class="line">within(com.zejian.dao..*)</span><br></pre></td></tr></table></figure>

<ul>
<li>+:匹配给定类的任意子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配实现了DaoUser接口的所有子类的方法</span></span><br><span class="line">within(com.zejian.dao.DaoUser+)</span><br></pre></td></tr></table></figure>

<ul>
<li>*：匹配任意数量的字符</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配com.zejian.service包及其子包中所有类的所有方法</span></span><br><span class="line">within(com.zejian.service..*)</span><br><span class="line"><span class="comment">//匹配以set开头，参数为int类型，任意返回值的方法</span></span><br><span class="line">execution(* set*(<span class="keyword">int</span>))</span><br></pre></td></tr></table></figure>

<h4 id="类型签名表达式"><a href="#类型签名表达式" class="headerlink" title="类型签名表达式"></a>类型签名表达式</h4><p>为了方便类型（如接口、类名、包名）过滤方法，Spring AOP 提供了within关键字。其语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配com.zejian.dao包及其子包中所有类中的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.zejian.dao..*)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类中所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.zejian.dao.UserDaoImpl)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配UserDaoImpl类及其子类中所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.zejian.dao.UserDaoImpl+)"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配所有实现UserDao接口的类的所有方法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"within(com.zejian.dao.UserDao+)"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="其他指示符"><a href="#其他指示符" class="headerlink" title="其他指示符"></a>其他指示符</h4><ul>
<li>bean：Spring AOP扩展的，AspectJ没有对于指示符，用于匹配特定名称的Bean对象的执行方法；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配名称中带有后缀Service的Bean。</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"bean(*Service)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut1</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>this ：用于匹配当前AOP代理对象类型的执行方法；请注意是AOP代理对象的类型匹配，这样就可能包括引入接口也类型匹配</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配了任意实现了UserDao接口的代理对象的方法进行过滤</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"this(com.zejian.spring.springAop.dao.UserDao)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut2</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>target ：用于匹配当前目标对象类型的执行方法；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配了任意实现了UserDao接口的目标对象的方法进行过滤</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"target(com.zejian.spring.springAop.dao.UserDao)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut3</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>within：用于匹配所以持有指定注解类型内的方法；请注意与within是有区别的， within是用于匹配指定类型内的方法执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配使用了MarkerAnnotation注解的类(注意是类)</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@within(com.zejian.spring.annotation.MarkerAnnotation)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut4</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@annotation(com.zejian.spring.MarkerMethodAnnotation) : 根据所应用的注解进行方法过滤</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配使用了MarkerAnnotation注解的方法(注意是方法)</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.zejian.spring.annotation.MarkerAnnotation)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut5</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>ok~，关于表达式指示符就介绍到这，我们主要关心前面几个常用的即可，不常用过印象即可。这里最后说明一点，切点指示符可以使用运算符语法进行表达式的混编，如and、or、not（或者&amp;&amp;、||、！），如下一个简单例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配了任意实现了UserDao接口的目标对象的方法并且该接口不在com.zejian.dao包及其子包下</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"target(com.zejian.spring.springAop.dao.UserDao) ！within(com.zejian.dao..*)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut6</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//匹配了任意实现了UserDao接口的目标对象的方法并且该方法名称为addUser</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"target(com.zejian.spring.springAop.dao.UserDao)&amp;&amp;execution(* com.zejian.spring.springAop.dao.UserDao.addUser(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut7</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、Aspect的优先级"><a href="#三、Aspect的优先级" class="headerlink" title="三、Aspect的优先级"></a>三、Aspect的优先级</h3><p>如果一个类拥有多个切面，如何定义优先级？</p>
<p>切面类只需实现org.springframework.core.Ordered 接口，该接口用于控制切面类的优先级，同时重写getOrder方法，定制返回值，返回值(int 类型)越小优先级越大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectOne</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointcut定义切点函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.deleteUser(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"myPointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知..AspectOne..执行顺序1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义优先级,值越低,优先级越高</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectTwo</span> <span class="keyword">implements</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Pointcut定义切点函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.zejian.spring.springAop.dao.UserDao.deleteUser(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">myPointcut</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"myPointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置通知....执行顺序1--AspectTwo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义优先级,值越低,优先级越高</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AspectOne肯定会优先于AspectTwo执行</p>
<h3 id="四、Spring-Aop的实现原理概要"><a href="#四、Spring-Aop的实现原理概要" class="headerlink" title="四、Spring Aop的实现原理概要"></a>四、Spring Aop的实现原理概要</h3><p>前面的分析中，我们谈到Spring AOP的实现原理是基于动态织入的动态代理技术，而AspectJ则是静态织入，而动态代理技术又分为Java JDK动态代理和CGLIB动态代理，前者是基于反射技术的实现，后者是基于继承的机制实现，下面通过一个简单的例子来分析这两种技术的代码实现。</p>
<h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>先看一个简单的例子，声明一个A类并实现ExInterface接口，利用JDK动态代理技术在execute()执行前后织入权限验证和日志记录，注意这里仅是演示代码并不代表实际应用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义的接口类，JDK动态代理的实现必须有对应的接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A类，实现了ExInterface接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">ExInterface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行A的execute方法..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要被代理的目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> A target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JDKProxy</span><span class="params">(A target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExInterface <span class="title">createProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ExInterface) Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用被代理类(目标对象)的任意方法都会触发invoke方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 被代理类的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 被代理类的方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//过滤不需要该业务的方法</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"execute"</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="comment">//调用前验证权限</span></span><br><span class="line">            AuthCheck.authCheck();</span><br><span class="line">            <span class="comment">//调用目标对象的方法</span></span><br><span class="line">            Object result = method.invoke(target, args);</span><br><span class="line">            <span class="comment">//记录日志数据</span></span><br><span class="line">            Report.recordLog();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="function">eles <span class="title">if</span><span class="params">(<span class="string">"delete"</span>.equals(method.getName()</span>))</span>&#123;</span><br><span class="line">            <span class="comment">//.....</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不需要增强直接执行原方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(target,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//测试验证</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">      A a=<span class="keyword">new</span> A();</span><br><span class="line">      <span class="comment">//创建JDK代理</span></span><br><span class="line">      JDKProxy jdkProxy=<span class="keyword">new</span> JDKProxy(a);</span><br><span class="line">      <span class="comment">//创建代理对象</span></span><br><span class="line">      ExInterface proxy=jdkProxy.createProxy();</span><br><span class="line">      <span class="comment">//执行代理对象方法</span></span><br><span class="line">      proxy.execute();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>invoke方法有三个参数：</p>
<ul>
<li><p>Object proxy ：生成的代理对象</p>
</li>
<li><p>Method method：目标对象的方法，通过反射调用</p>
</li>
<li><p>Object[] args：目标对象方法的参数</p>
<p>这就是Java JDK动态代理的代码实现过程，小结一下，运用JDK动态代理，被代理类(目标对象，如A类)，必须已有实现接口如(ExInterface)，因为JDK提供的Proxy类将通过目标对象的类加载器ClassLoader和Interface，以及句柄(Callback)创建与A类拥有相同接口的代理对象proxy，该代理对象将拥有接口ExInterface中的所有方法，同时代理类必须实现一个类似回调函数的InvocationHandler接口并重写该接口中的invoke方法，当调用proxy的每个方法(如案例中的proxy#execute())时，invoke方法将被调用，利用该特性，可以在invoke方法中对目标对象(被代理对象如A)方法执行的前后动态添加其他外围业务操作，此时无需触及目标对象的任何代码，也就实现了外围业务的操作与目标对象(被代理对象如A)完全解耦合的目的。当然缺点也很明显需要拥有接口，这也就有了后来的CGLIB动态代理了</p>
</li>
</ul>
<h4 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h4><p>​    通过CGLIB动态代理实现上述功能并不要求目标对象拥有接口类，实际上CGLIB动态代理是通过继承的方式实现的，因此可以减少没必要的接口，下面直接通过简单案例协助理解（CGLIB是一个开源项目，github网址是：<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener">https://github.com/cglib/cglib</a>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被代理的类即目标对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行A的execute方法..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 被代理的目标类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> A target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CGLibProxy</span><span class="params">(A target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">createProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 使用CGLIB生成代理:</span></span><br><span class="line">        <span class="comment">// 1.声明增强类实例,用于生产代理类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 2.设置被代理类字节码，CGLIB根据字节码生成被代理类的子类</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">// 3.//设置回调函数，即一个方法拦截</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 4.创建代理:</span></span><br><span class="line">        <span class="keyword">return</span> (A) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回调函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 委托类方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 每个被代理的方法都对应一个MethodProxy对象，</span></span><br><span class="line"><span class="comment">     *                    methodProxy.invokeSuper方法最终调用委托类(目标类)的原始方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   <span class="comment">//过滤不需要该业务的方法</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="string">"execute"</span>.equals(method.getName())) &#123;</span><br><span class="line">          <span class="comment">//调用前验证权限(动态添加其他要执行业务)</span></span><br><span class="line">          AuthCheck.authCheck();</span><br><span class="line"></span><br><span class="line">          <span class="comment">//调用目标对象的方法(执行A对象即被代理对象的execute方法)</span></span><br><span class="line">          Object result = methodProxy.invokeSuper(proxy, args);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//记录日志数据(动态添加其他要执行业务)</span></span><br><span class="line">          Report.recordLog();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"delete"</span>.equals(method.getName()))&#123;</span><br><span class="line">          <span class="comment">//.....</span></span><br><span class="line">          <span class="keyword">return</span> methodProxy.invokeSuper(proxy, args);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果不需要增强直接执行原方法</span></span><br><span class="line">      <span class="keyword">return</span> methodProxy.invokeSuper(proxy, args);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    从代码看被代理的类无需接口即可实现动态代理，而CGLibProxy代理类需要实现一个方法拦截器接口MethodInterceptor并重写intercept方法，类似JDK动态代理的InvocationHandler接口，也是理解为回调函数，同理每次调用代理对象的方法时，intercept方法都会被调用，利用该方法便可以在运行时对方法执行前后进行动态增强。关于代理对象创建则通过Enhancer类来设置的，Enhancer是一个用于产生代理对象的类，作用类似JDK的Proxy类，因为CGLib底层是通过继承实现的动态代理，因此需要传递目标对象(如A)的Class，同时需要设置一个回调函数对调用方法进行拦截并进行相应处理，最后通过create()创建目标对象(如A)的代理对象，运行结果与前面的JDK动态代理效果相同。</p>
<p>​    Spring AOP 确实是通过 CGLIB或者JDK代理 来动态地生成代理对象，这个代理对象指的就是 AOP 代理累，而 AOP 代理类的方法则通过在目标对象的切入点动态地织入增强处理，从而完成了对目标方法的增强。这里并没有非常深入去分析这两种技术，更倾向于向大家演示Spring AOP 底层实现的最简化的模型代码，Spring AOP内部已都实现了这两种技术，Spring AOP 在使用时机上也进行自动化调整，当有接口时会自动选择JDK动态代理技术，如果没有则选择CGLIB技术，当然Spring AOP的底层实现并没有这么简单，为更简便生成代理对象，Spring AOP 内部实现了一个专注于生成代理对象的工厂类，这样就避免了大量的手动编码，这点也是十分人性化的，但最核心的还是动态代理技术。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/01/02/AspectJ%E5%92%8CSpring%E7%9A%84AOP/" data-id="ck4wr4tq10000f1ad6dd4ex7g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/01/07/SpringIOC%E5%AD%A6%E4%B9%A0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Spring
        
      </div>
    </a>
  
  
    <a href="/2019/12/30/logback%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">logback使用详解</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/07/SpringIOC%E5%AD%A6%E4%B9%A0/">Spring</a>
          </li>
        
          <li>
            <a href="/2020/01/02/AspectJ%E5%92%8CSpring%E7%9A%84AOP/">AspectJ和Spring的AOP</a>
          </li>
        
          <li>
            <a href="/2019/12/30/logback%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/">logback使用详解</a>
          </li>
        
          <li>
            <a href="/2019/12/30/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/">开发技巧</a>
          </li>
        
          <li>
            <a href="/2019/12/29/Hello/">Hello</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>